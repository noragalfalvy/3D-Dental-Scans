# Grid Splitting Algorithm
# Import Required Packages
import numpy as np
import vedo

# Import Required functions
from Occlusal_plane_aprox_algorithm import highest_points

# Function that creates the grid according to the size indicated by the user
def create_grid(mesh, cell_size, bounds):
    '''
    Function to generate the grid based on user input "Grid Size"

    Input: Inverted mesh and the desired cell size for the grid
    Output: grid_cells (list of lists - contains XY coordinates of each grid cell) and vgrid (mesh object)
    '''

    # 1. Calculate the total width and height of the area to be covered
    x_width = bounds[1] - bounds[0]  # Total width in X
    y_height = bounds[3] - bounds[2]  # Total height in Y

    # 2. Calculate the number of cells needed in each direction
    x_cells = int(np.ceil(x_width / cell_size))  # Number of cells in X
    y_cells = int(np.ceil(y_height / cell_size))  # Number of cells in Y

    # 3. Create grid using numpy's linspace function
    x_edges = np.linspace(bounds[0], bounds[1], x_cells + 1)  # Edges in X
    y_edges = np.linspace(bounds[2], bounds[3], y_cells + 1)  # Edges in Y

    # 4. Create the grid cells
    grid_cells = []
    for i in range(len(x_edges) - 1):
        for j in range(len(y_edges) - 1):
            cell_bounds = [
                x_edges[i],     # xmin
                x_edges[i + 1], # xmax
                y_edges[j],     # ymin
                y_edges[j + 1]  # ymax
            ]
            grid_cells.append(cell_bounds)

    return grid_cells

# Function that finds the highest point in each segment:
def find_highest_points_in_segments(mesh, grid_cells, inclusion_criterion, normal, points):
    """
    Function to find the highest points in segments defined by grid cells.

    Input: mesh, grid_cells (each cell generated by the grid), inclusion_criterion (user input variable), normal, points
    Output: highest points in each cell, list of points in each cell, list of thresholds calculated per cell.
    """
    # 1. Extract all vertices (points) from the mesh.
    points_array = np.array(points)

    # 2. Initialize result lists:
    #    - `highest_points` will store the highest Z points for each grid cell.
    #    - `points_in_cells` will store all points belonging to each grid cell.
    #    - `inclusion_thresholds` will store thresholds calculated for each cell.
    highest_points = []
    points_in_cells = []
    inclusion_thresholds = []

    # 3. Iterate through each grid cell defined in `grid_cells`.
    for cell_bounds in grid_cells:
        # 3.1 Create a mask to filter points that fall within the cell's XY bounds:
        #      - `cell_bounds[0]` to `cell_bounds[1]`: X range.
        #      - `cell_bounds[2]` to `cell_bounds[3]`: Y range.
        mask = (
            (points_array[:, 0] >= cell_bounds[0]) & (points_array[:, 0] <= cell_bounds[1]) &
            (points_array[:, 1] >= cell_bounds[2]) & (points_array[:, 1] <= cell_bounds[3])
        )

        # 3.2 Extract points inside the current grid cell using the mask.
        points_in_cell = points_array[mask]
        points_in_cells.append(points_in_cell)

        # 4. If the cell contains any points:
        if points_in_cell.size > 0:
            # 4.1 Find the point with the highest Z-coordinate:
            #     - `np.argmax(points_in_cell[:, 2])` finds the index of the max Z value.
            highest_z_point = points_in_cell[np.argmax(points_in_cell[:, 2])]
            highest_points.append(highest_z_point)

            # 4.2 Calculate the inclusion threshold for this highest point:
            #     - The threshold is computed as `highest_z_point + np.dot(inclusion_criterion, normal)`.
            #     - This accounts for the normal direction and criterion vector.
            threshold = highest_z_point + np.dot(inclusion_criterion, normal)
            inclusion_thresholds.append(threshold)

    # 5. Return results:
    #    - `highest_points`: A list of the highest Z points for each grid cell.
    #    - `points_in_cells`: A list containing all points within each grid cell.
    #    - `inclusion_thresholds`: A list of thresholds calculated for the highest points.
    return np.array(highest_points), points_in_cells, inclusion_thresholds

# Associate points
def associate_high_points_grid_cell(highest_points_segments, grid_cells, points):
    """
    Function to properly associate the high points and the grid cells

    Input: highest_points, grid_cells
    Output: Dictionary where the keys are the indices of the cells, and the values are the associated highest points.
    """
    # 1. Create a dictionary to store the point assignment
    point_and_grid_cell = {}

    # 2. Iterate over all the highest points
    for i, point in enumerate(highest_points_segments):
        x_coord, y_coord = point[0], point[1]

        # 2.1 Iterate over the grid cells to find the corresponding cell
        for cell_index, (x_min, x_max, y_min, y_max) in enumerate(grid_cells):
            # 2.1.1 Check if the point falls within the bounds of the current cell
            if x_min <= x_coord <= x_max and y_min <= y_coord <= y_max:
                # 2.1.2 Assign the point to its corresponding cell
                point_and_grid_cell[cell_index] = point
                break  # Exit the loop once the corresponding cell has been found

    return point_and_grid_cell

# Grid Cutting Algorithm
def determine_high_point_and_grid_cells(mesh, cell_size, inclusion_criterion, bounds, normal, points):
    '''
    Function to determine the highest points and the grid cells

    Input: mesh, cell_size, inclusion_criterion, bounds, normal, points
    Output: grid_cells, highest_points_segments, points_in_cells, inclusion_thresholds, point_and_grid_cell
    '''
    # Test
    grid_cells = create_grid(mesh, cell_size, bounds)
    highest_points_segments, points_in_cells, inclusion_thresholds = find_highest_points_in_segments(mesh, grid_cells, inclusion_criterion, normal, points)
    point_and_grid_cell = associate_high_points_grid_cell(highest_points_segments, grid_cells, points)

    return grid_cells, highest_points_segments, points_in_cells, inclusion_thresholds, point_and_grid_cell
